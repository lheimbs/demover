#!/bin/bash

# Move desktop-environment from main computer onto fresh installed distro

# VARIABLES
PKGMGR=""
PKGINSTALL=""
BUILDFROMSOURCE=""
PKGMGR_UPDATE=""
PACKAGES="packages"
CONFIGS="configs/"
LINKS="links"
VERBOSE=""
PROMPT_OPTION=""
FAILED_PACKAGES=()

# create new log file
echo "" > log

# functions:
usage() {
    echo "Script to move a given desktop-configuration to a newly installed distro." >&2
    echo >&2
    echo "Usage: ${0} [Arguments] PKGMGR       install desktopenvironment" >&2
    echo "With no arguments given: Read packages from $(dirname '${0}')/packages, configs from $(dirname '${0}')/configs/ and links from $(dirname '${0}')/links." >&2
    echo "PKGMGR is the packagemanager thats used on the distro." >&2
    echo >&2
    echo "Arguments:" >&2
    echo "      -p FILE     Specify a file that contains the packages that are to be installed." >&2
    echo "      -c FOLDER   Specify a folder to look for config files." >&2
    echo "      -l FILE     Specify a file that contains links to packages from AUR or how the package ist built from source." >&2
    echo "      -o          Confirm command before installing." >&2
    echo "      -v          Increase verbosity." >&2
}

confirm_selection() {
    if [[ "${PROMPT_OPTION}" = 'true' ]]; then 
        read -r -p "Are you sure? [y/N] " response
        case "$response" in 
            [yY][eE][sS]|[yY]|[jJ][aA])
                return 1
                ;;
            *)
                return 0
                ;;
        esac
    else
        return 1
    fi
}

title () {
    echo "=================================================="
    echo "==========  Desktop Environment Mover  ==========="
    echo "=================================================="
    echo
}

vlog() {
    local MESSAGE="${@}"
    if [[ "${VERBOSE}" = 'true' ]]; then
        echo "${MESSAGE}"
    fi
}

echo_status() {
    vlog "Verbose mode is on."

    vlog "Packagemanager: ${PKGMGR}."
    vlog "Package Install Command: ${PKGINSTALL}."
    if [[ ${BUILDFROMSOURCE} != "" ]]; then
        vlog "Build from source command: ${BUILDFROMSOURCE}."
    fi
    vlog "Packages file: ${PACKAGES}."
    vlog "Configs folder: ${CONFIGS}."
    vlog "Links for additional GIT/AUR Packages: ${LINKS}."
}

# Get pkgmgr-cmd and pkmgr builf from source if availabe
read_pkgmgr_file() {
    if [[ -f "pkgmgrs/${PKGMGR}" ]]; then
        vlog "Reading from file 'pkgmgrs/${PKGMGR}'"
        while IFS= read -r LINE; do
            IFS=':' read -ra PART <<< "$LINE"
            vlog "${PART[0]}: ${PART[1]}"
            if [[ ${PART[0]} = "pkg-install" ]]; then
                PKGINSTALL="${PART[1]}"
            elif [[ ${PART[0]} = "build-from-source" ]]; then
                BUILDFROMSOURCE="${PART[1]}"
            elif [[ ${PART[0]} = "update" ]]; then
                PKGMGR_UPDATE="${PART[1]}"
            fi
        done < "pkgmgrs/${PKGMGR}"
    else
        return 1
    fi
    return 0
}

# React to exitcodes of executed commands
exec_cmd_to_pipe() {
    local cmd="${@}"
    vlog "cmd: ${cmd}"

    set -o pipefail
    exec {fd}>&2

    local eval_cmd_verbose=" |& tee /dev/fd/$fd | ( ! grep -q -e '^Err:' -e '^[WE]:' )"
    local eval_cmd=" |& ( ! grep -q -e '^Err:' -e '^[WE]:' )"

    if [[ ${VERBOSE} = 'true' ]]; then
        cmd+=$eval_cmd_verbose
    else
        cmd+=$eval_cmd
    fi

    echo "${cmd}"

    eval $cmd

    local result=$?

    exec {fd}>&-
    if [[ "${result}" -ne 0 ]]; then
        # handle exitcode
        echo "Command '${cmd}' failed with exitcode $result."
    fi
}

# Execute commands but write output to log file and check that for errors
exec_cmd_to_file() {
    local cmd="${@}"
    local success="false"
    #local delay='0.75'
    #local spinstr='\|/-'
    #local temp

    cmd+=" &> command.log"
    
    #while eval $cmd; do
    #    temp="${spinstr#?}"
    #    printf " [%c]  " "${spinstr}"
    #    spinstr=${temp}${spinstr%"${temp}"}
    #    sleep "${delay}"
    #    printf "\b\b\b\b\b\b"
    #done
    
    eval $cmd
    retVal=${?} 
    #printf "    \b\b\b\b"

    if grep -q -e '^Error' -e '^Err:' -e '^E:' command.log; then
        echo "Error detected."
        echo "Error: ${cmd}" >> log
        cat command.log >> log
        echo "" >> log
        echo "" >> log
    elif [[ ${retVal} -ne 0 ]]; then
        echo "Error detected: Exitcode: ${retVal}."
        echo "Error: ${cmd}" >> log
        cat command.log >> log
        echo "" >> log
        echo "" >> log
    elif grep -q -e '^W' -e '^Warning' -e '^Warn' command.log; then
        vlog "Warning detected."
        echo "Warning detected." >> log
        cat command.log >> log
        echo "" >> log
        echo "" >> log
        success='true'
    else
        vlog "Command ran successfully."
        success='true'
    fi
    
    rm -f command.log

    if [[ ${success} = 'true' ]]; then
        return 0
    else
        return 1
    fi
}

# ==================================================================
# ==============  SCRIPT START =====================================
# ==================================================================

# ----- user needs rot access to run; exitcode 1 = no root -----
if [[ ${UID} -ne 0 ]]; then
    echo "You need root privileges to run this script!"
    exit 1
fi

# ----- parse options -----
# EXITSTATUS 3: file is not a valid textfile
# EXITSTATUS 4: folder is not valid
while getopts vop:c:l OPTION; do
    case ${OPTION} in
        v)
            VERBOSE='true'
            ;;
        p)
            if [[ -f ${OPTARG} ]]; then
                PACKAGES=${OPTARG} 
            else
                echo "${OPTARG} is not a valid file." >&2
                exit 3
            fi
            ;;
        c)
            if [[ -d ${OPTARG} ]]; then
                CONFIGS=${OPTARG} 
            else
                echo "${OPTARG} is not a valid folder." >&2
                exit 4
            fi
            ;;
        l)
            if [[ -f ${OPTARG} ]]; then
                LINKS=${OPTARG} 
            else
                echo "${OPTARG} is not a valid file." >&2
                exit 3
            fi
            ;;
        o)
            PROMPT_OPTION='true'
            ;;
    esac
done

# ----- Remove the options, if pkgmgr argument is mussing: EXITCODE 2 = no pkgmgr supplied -----
shift "$(( OPTIND - 1 ))"
if [[ "${#}" -ne 1 ]]; then
    usage
    exit 2
fi

PKGMGR=${@}

# ----- get pkginstall and buildfromsource commands -----
# if read_pkgmgr_file return is != 0: EXITCODE 5 = supplied pkgmgr invalid
read_pkgmgr_file
if [[ "${?}" -ne 0 ]]; then
    echo "File 'pkgmgrs/${PKGMGR}' invalid."
    exit 3
fi
echo_status

# ----- Update package list -----
if [[ ${PKGMGR_UPDATE} != "" ]]; then
    echo "Updating Package list."
    exec_cmd_to_file ${PKGMGR_UPDATE}
fi

IFS=$'\r\n :'
GLOBIGNORE='*'
command eval 'PACKAGES_LIST=($(cat ${PACKAGES}))'

# ----- Package installation section -----
# iterate over array
for PKGPART in "${PACKAGES_LIST[@]}"; do
    INSTALL="yes | ${PKGINSTALL} ${PKGPART[0]}"
    echo "Proposing to run '${INSTALL}'."
    confirm_selection "Execute command?"
    if [[ ${?} -eq 1 ]]; then
        exec_cmd_to_file "${INSTALL}"
        if [[ $? -ne 0 ]]; then
            FAILED_PACKAGES+=(${PKGPART[0]})
        fi
    else
        vlog "${PKGPART[0]} will not be installed."
    fi
done

if [[ ${#FAILED_PACKAGES[@]} -ne 0 ]]; then
    echo "${#FAILED_PACKAGES[@]} packages could not be installed:"
    echo "${FAILED_PACKAGES[@]}"
fi
